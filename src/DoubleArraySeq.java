/**
 * A <code>DoubleArraySeq</code> keeps track of a sequence of double numbers.
 * The sequence can have a special &quot;current element&quot;, which is
 * specified and accessed through four methods that are not available in the
 * <code>IntArrayBag</code> class (<code>start</code>, <code>getCurrent</code>,
 * <code>advance</code>, and <code>isCurrent</code>).
 * <p/>
 * Note that the <code>addAfter<code> and <code>addBefore</code> methods work
 * efficiently (without needing more memory) until the current capacity of the
 * sequence is reached.
 * <p/>
 * Note also that any attempt to increase the capacity of any sequence beyond
 * <code>Integer.MAX_VALUE</code> will cause the sequence to fail with an
 * arithmetic overflow.
 * <p/>
 * <b>Limitations:</b><br>
 * <ul>
 * <li>The capacity of a sequence change change after it is created, but
 * the maximum capacity is limited by the amount of free memory on the
 * machine.  The constructor, <code>addAfter</code>, <code>addBefore</code>,
 * <code>clone</code>, and <code>concatenation</code> will result in an
 * <code>OutOfMemoryError</code> when free memory is exausted.</li>
 * <li>A sequence's capacity cannot exceed the largest integer
 * 2,147,483,647 (<code>Integer.Max_VALUE</code>).  Any attempt to
 * create a larger capacity results in failure due to an arithmetic
 * overflow.</li> </ul> NOTE: Some of these exceptions are automatically
 * generated by the Java Virtual Machine
 *
 * @author Dr. Dalton
 * @author Dr. Kreahling
 * @author Michael Main
 * @author Logan Gillespie
 * @author Robert (Matt) Anger
 * @version 1.2
 */
public class DoubleArraySeq implements Sequence {

 /* Invariant of the DoubleArraySeq class:
     *   1. The number of elements in the sequences is in the instance variable
     *      manyItems.
     *   2. For an empty sequence (with no elements), we do not care what is
     *      stored in any of data; for a non-empty sequence, the elements of
     *      the sequence are stored in data[0] through data[manyItems - 1], and
     *      we don't care what's in the rest of data.
     *   3. If there is a current element, then it lies in data[currentIndex];
     *      if there is no current element, then currentIndex equals -1.
     */

    /**
     * The default capacity of a newly constructed <code>DoubleArraySeq</code>.
     * (10 elements)
     */
    public final static int DEFAULT_CAPACITY = 10;

    /**
     * A sentinel value used for the current element to indicate that no
     * current element exists.
     */
    private final static int NO_CURRENT = -1;

    /**
     * The index of the current element in this sequence.
     */

    private int currentElement;

    /**
     * The elements of this sequence.
     */
    private double[] data;

    /**
     * The current length of this sequence
     * (i.e., how many items are in this sequence) NOT the length of the array.
     */
    private int manyItems;

    /**
     * Initializes an empty sequence with an initial capacity of
     * <code>DEFAULT_CAPACITY</code>.  (This constructor should use
     * <code>this(...)</code> to invoke the second constructor.)
     *
     * @throws OutOfMemoryError if there is insufficient memory for:
     *                          <code>new double[DEFAULT_CAPACITY]</code>.
     * @postcondition This sequence is empty and has an initial capacity of
     * <code>DEFAULT_CAPACITY</code>.
     */
    public DoubleArraySeq() {
        this(DEFAULT_CAPACITY);

        if (data.length <= 0 && data.length == DEFAULT_CAPACITY) {
            throw new IllegalStateException();
        }
    }

    /**
     * Initializes an empty sequence with the specified initial capacity.
     *
     * @throws OutOfMemoryError if there is insufficient memory for:
     *                          <code>new double[initialCapacity]</code>.
     * @postcondition This sequence is empty and has an initial capacity of
     * <code>initialCapacity</code>.
     */

    public DoubleArraySeq(int initialCapacity) {
        try {
            data = new double[initialCapacity];
        } catch (OutOfMemoryError e) {
            System.out.println("**Error in code**");
            e.printStackTrace();
        }
        if (data.length <= 0 && data.length == DEFAULT_CAPACITY) {
            throw new IllegalStateException();
        }
        currentElement = NO_CURRENT;
    }

    /**
     * Creates a new sequence that contains all the elements from s1 followed
     * by all of the elements from s2.
     *
     * @param s1 the first of two sequences.
     * @param s2 the second of two sequences.
     * @return a new sequence that has the elements of s1 followed by the
     * elements of s2 (with no current element).
     * @throws NullPointerException if s1 or s2 are null.
     * @throws OutOfMemoryError     if there is insufficient memory for the
     *                              new sequence.
     * @precondition neither s1 nor s2 are null.
     */
    public static DoubleArraySeq concatenation(DoubleArraySeq s1,
                                               DoubleArraySeq s2)
            throws NullPointerException, OutOfMemoryError {
        if (s1 == null || s2 == null)
            throw new NullPointerException("Cannot concatenate a null object!");
        DoubleArraySeq newSeq = new DoubleArraySeq(s1.size() + s2.size());
        newSeq.addAll(s1);
        newSeq.addAll(s2);
        newSeq.manyItems = s1.manyItems + s2.manyItems;
        newSeq.currentElement = NO_CURRENT;
        return newSeq;
    }

    /**
     * Determines the current number of elements stored in this sequence.
     *
     * @return the current number of elements stored in this sequence.
     */
    public int size() {
        return manyItems;
    }

    /**
     * This function returns and element a specified index
     *
     * @param index position of element to be retrieved
     * @return double element from array
     * @throws NullPointerException if the index is not inside 
     *                              the array bounds
     */
    public double get(int index) {
        double element;
        if (index < this.size()) {
            element = this.data[index];
        } else {
            throw new NullPointerException("Index is out of bounds!");
        }
        return element; 
    }

    /**
     * Sets the current element at the front of this sequence.
     *
     * @postcondition If this sequence is not empty, the front element of
     * this sequence is now the current element;
     * otherwise, there is no current element.
     */
    public void start() {
        if (this.size() > 0) {
            currentElement = 0;
        } else {
            currentElement = NO_CURRENT;
        }
    }

    /**
     * Returns a copy of the current element in this sequence.
     *
     * @return double if there is a current element.
     * @throws IllegalStateException - if there is no currentElement
     * @precondition isCurrent() returns true.
     */

    public double getCurrent() {
        if (!this.isCurrent()) {
            throw new IllegalStateException("There is no current element!");
        }
        return data[currentElement];
    }

    /**
     * Adds a new element to this sequence after the current element.  If this
     * new element would take this beyond its current capacity, then the
     * capacity is increased before adding the new element.
     *
     * @param element the new element that is being added to this sequence.
     * @throws OutOfMemoryError if there is insufficient memory to increase
     *                          the  size of this sequence.
     * @postcondition a new copy of the element has been added to this
     * sequence. If there was a current element,
     * then this method places the new element after the current element. If
     * there was no current element,
     * then this method places the new element at the end of this sequence.
     * The newly added element becomes the new current element of this sequence.
     */
    public void addAfter(double element) {
        this.ensureCapacity(this.size() + 1); 
        if (this.size() <= 0) {
            currentElement = 0;
            data[currentElement] = element;
        } else {
            if (!this.isCurrent()) {
                data[this.size()] = element;
                currentElement = this.size();
            } else {
                if (currentElement + 1 != this.size()) {
                    System.arraycopy(data, currentElement, data,
                            currentElement + 1, this.size());
                    currentElement++;
                    data[currentElement] = element;
                } else {
                    currentElement++;
                    data[currentElement] = element;
                }
            }
        }
        manyItems++;
    }

    /**
     * Places the contents of another sequence at the end of this sequence.
     *
     * @param other a sequence show contents will be placed at the end of this
     *              sequence.
     * @throws NullPointerException if <code>other</code> is null.
     * @throws OutOfMemoryError     if there is insufficient memory to
     *                              increase the capacity of this sequence.
     * @precondition other must not be null.
     * @postcondition the elements from <code>other</code> have been placed
     * at  the end of this sequence.  The current
     * element of this sequence remains where it was, and <code>other</code>
     * is  unchanged.
     */
    public void addAll(Sequence other) {
        if (other != null) {
            this.ensureCapacity(other.size() + this.size());
            if (other instanceof DoubleArraySeq) {
                int oSize = other.size();
                //Temp reference to other as a DoubleArraySeq 
                DoubleArraySeq tmp = (DoubleArraySeq) other;
                System.arraycopy(tmp.data, 0, this.data,
                        this.manyItems, oSize);

            }

            manyItems = other.size() + manyItems;
        } else {
            throw new NullPointerException("DoubleArraySeq parameter is null");
        }
    }

    /**
     * Adds a new element to this sequence before the current element.  If this
     * new element would take this beyond its current capacity, then the
     * capacity is increased before adding the new element.
     *
     * @param element the new element that is being added to this sequence.
     * @throws OutOfMemoryError if there is insufficient memory to increase
     * the size of this sequence.
     * @postcondition a new copy of the element has been added to this
     * sequence.  If there was a current element,
     * then this method places the new element before the current element. If
     * there was no current element,
     * the new element at the front of this sequence.  The newly added
     * element becomes the new current element of
     * this sequence.
     */
    public void addBefore(double element) {
        this.ensureCapacity(this.size() + 1); 
        if (this.size() <= 0) {
            currentElement = 0;
            data[currentElement] = element;
        } else {

            if (!this.isCurrent()) {
                currentElement = 0;
                System.arraycopy(data, currentElement, data,
                        currentElement + 1, this.size());
                data[currentElement] = element;

            } else {
                System.arraycopy(data, currentElement, data,
                        currentElement + 1, this.size());
                data[currentElement] = element;
            }
        }
        manyItems++;
    }


    /**
     * Move forward so that the current element is now the next element in the
     * sequence.
     *
     * @throws IllegalStateException if there is not current element.
     * @precondition <code>isCurrent()</code> returns <code>true</code>.
     * @postcondition If the current element was already the end element of
     * this sequence (with nothing after it),
     * then there is no longer any current element.  Otherwise,
     * the new element is the element immediately after the
     * original current  element.
     */
    public void advance() {
        int newCur = currentElement + 1;
        if (this.isCurrent()) {
            if (newCur == this.size()) {
                this.currentElement = NO_CURRENT;
            } else {
                this.currentElement = newCur;
            }
        } else {
            throw new IllegalStateException("There is no current element!");
        }
    }

    /**
     * Creates a copy of this sequence.
     *
     * @return a copy of this sequence.  Subsequent changes to the copy will
     * not affect the original, nor vice versa.
     * @throws OutOfMemoryError if there is insufficient memory for creating
     * the clone object.
     * @throws RuntimeException if this class does not implement Cloneable.
     */
    @Override
    public Sequence clone() {
        DoubleArraySeq theCopy = null;
        try {
            theCopy = (DoubleArraySeq) super.clone();
            theCopy.data = data.clone();
        } catch (CloneNotSupportedException ex) {
            throw new RuntimeException("This class does not implement the " +
                    "Cloneable interface");
        } catch (OutOfMemoryError ex) {
            System.out.println(ex.getMessage());
        }
        return theCopy;
    }


    /**
     * Change the current capacity of this sequence to be at least the specified
     * value.
     *
     * @param minimumCapacity the new minimum capacity for this sequence.
     * @throws OutOfMemoryError if there is insufficient memory for the a new
     * array: <code>new
     *                          double[minimumCapacity]</code>.
     * @postcondition This sequence's capacity has been changed to be at
     * least minimumCapacity, but no less than size.
     */
    public void ensureCapacity(int minimumCapacity) {
        int factor = 2; 
        try {
            if (data.length < minimumCapacity) {

                double[] tmp = new double[minimumCapacity * factor];
                System.arraycopy(data, 0, tmp, 0, this.size());
                data = tmp;
            }
        } catch (OutOfMemoryError er) {
            System.out.println(er.getMessage());
        }
    }

    /**
     * Determines if this object is equal to the other object.
     *
     * @return true if this object is equal to the other object,
     * false otherwise.
     */
    @Override
    public boolean equals(Object other) {
        boolean result = true;
        if (other == null) {
            result = false;
        }
        if (!(other instanceof DoubleArraySeq)) {
            result = false;
        }
        if (this.size() == ((DoubleArraySeq) other).size()) {
            for (int i = 0; i < manyItems; i++) {
                if (this.data[i] != ((DoubleArraySeq) other).data[i]) {
                    result = false;
                }
            }
        }
        result = (this.currentElement == ((DoubleArraySeq) other)
                .currentElement);

        return result;
    }

    /**
     * Determines the current capacity of this sequence.
     *
     * @return the current capacity of this sequence.
     */
    public int getCapacity() {
        return data.length;
    }

    /**
     * Determines whether this sequence has specified a current element.
     *
     * @return <code>true</code> if there is a current element,
     * or <code>false</code> otherwise.
     */
    public boolean isCurrent() {
        return currentElement != NO_CURRENT;
    }

    /**
     * Removes the current element from this sequence.
     *
     * @throws IllegalStateException if there is no current element.
     * @precondition <code>isCurrent()</code> returns true.
     * @postcondition The current element has been removed from this
     * sequence, and the following element (if there is
     * one) is now the new current element.  If there was no following
     * element, then there is now no current element.
     */
    public void removeCurrent() {
        if (currentElement <= NO_CURRENT) {
            throw new IllegalStateException("There is no current element to " +
                    "remove!");
        } else {
            if (currentElement + 1 == this.size()) {
                --manyItems;
                this.currentElement = NO_CURRENT;
            } else {
                System.arraycopy(data, currentElement + 1, data,
                        currentElement, this.getCapacity() - currentElement - 1);
                manyItems--;
            }
        }
    }

    /**
     * Returns a String representation of this sequence.  If the sequence is
     * empty, the method should return &quot;&lt;&gt;&quot;.  If the sequence
     * has one item, say 1.1, and that item is not the current item, the method
     * should return &quot;&lt;1.1&gt;&quot;.  If the sequence has more than one
     * item, they should be separated by commas, for example:
     * &quot;&lt;1.1, 2.2, 3.3&gt;&quot;.  If there exists a current item, then
     * that item should be surrounded by square braces.  For example, if the
     * second item is the current item, the method should return: &quot;&lt;1
     * .1, [2.2], 3.3&gt;&quot;.
     *
     * @return a String representation of this sequence.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("<");
        if (data == null || manyItems == 0) {
            sb.append(">");
        } else {
            for (int i = 0; i < manyItems; i++) {
                if (i == currentElement) {
                    sb.append("[").append(data[i]).append("]");
                } else {
                    sb.append(data[i]);
                }
                if (i < manyItems - 1) {
                    sb.append(", ");
                }
            }
            sb.append(">");
        }
        return sb.toString();
    }

    /**
     * Reduces the capacity of the sequence to the number of elements currently
     * in the sequence.
     *
     * @throws OutOfMemoryError if there is insufficient memory for altering
     *                          the capacity.
     * @postcondition This sequence's capacity has been changed to its current
     * size.
     */
    public void trimToSize() {
        double[] datanew = new double[this.size()];
        System.arraycopy(data, 0, datanew, 0, this.size());
        data = datanew;
        manyItems = data.length;
    }
}
